<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content=
"width=device-width, initial-scale=1">
<title>Lapwing! Documentation | Protocol</title>
<link rel="stylesheet" type="text/css" href=
"/doku/static/css/main.css">
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="/doku/static/js/mathjax/tex-chtml.js" id=
"MathJax-script" async></script>
<style type="text/css">
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #8f5902; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #ef2929 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #204a87; font-weight: bold } /* Keyword */
.highlight .l { color: #000000 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #ce5c00; font-weight: bold } /* Operator */
.highlight .x { color: #000000 } /* Other */
.highlight .p { color: #000000; font-weight: bold } /* Punctuation */
.highlight .ch { color: #8f5902; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #8f5902; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #8f5902; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #8f5902; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #8f5902; font-style: italic } /* Comment.Single */
.highlight .cs { color: #8f5902; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #ef2929 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #a40000; font-weight: bold } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #204a87; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #204a87; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #204a87; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #204a87; font-weight: bold } /* Keyword.Type */
.highlight .ld { color: #000000 } /* Literal.Date */
.highlight .m { color: #0000cf; font-weight: bold } /* Literal.Number */
.highlight .s { color: #4e9a06 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #204a87 } /* Name.Builtin */
.highlight .nc { color: #000000 } /* Name.Class */
.highlight .no { color: #000000 } /* Name.Constant */
.highlight .nd { color: #5c35cc; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #ce5c00 } /* Name.Entity */
.highlight .ne { color: #cc0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #000000 } /* Name.Function */
.highlight .nl { color: #f57900 } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #204a87; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #000000 } /* Name.Variable */
.highlight .ow { color: #204a87; font-weight: bold } /* Operator.Word */
.highlight .w { color: #f8f8f8; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #0000cf; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #0000cf; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #0000cf; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000cf; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #0000cf; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { color: #4e9a06 } /* Literal.String.Affix */
.highlight .sb { color: #4e9a06 } /* Literal.String.Backtick */
.highlight .sc { color: #4e9a06 } /* Literal.String.Char */
.highlight .dl { color: #4e9a06 } /* Literal.String.Delimiter */
.highlight .sd { color: #8f5902; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #4e9a06 } /* Literal.String.Double */
.highlight .se { color: #4e9a06 } /* Literal.String.Escape */
.highlight .sh { color: #4e9a06 } /* Literal.String.Heredoc */
.highlight .si { color: #4e9a06 } /* Literal.String.Interpol */
.highlight .sx { color: #4e9a06 } /* Literal.String.Other */
.highlight .sr { color: #4e9a06 } /* Literal.String.Regex */
.highlight .s1 { color: #4e9a06 } /* Literal.String.Single */
.highlight .ss { color: #4e9a06 } /* Literal.String.Symbol */
.highlight .bp { color: #3465a4 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #000000 } /* Name.Function.Magic */
.highlight .vc { color: #000000 } /* Name.Variable.Class */
.highlight .vg { color: #000000 } /* Name.Variable.Global */
.highlight .vi { color: #000000 } /* Name.Variable.Instance */
.highlight .vm { color: #000000 } /* Name.Variable.Magic */
.highlight .il { color: #0000cf; font-weight: bold } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div id="translation-notice">
<div class="message is-info">
<div class="message-body">
<p>This website was mostly translated automatically from the
<a href="/doku/protokoll">German version</a>. We apologize for any
translation errors.</p>
<span class="x" onclick=
"localStorage.setItem('translation-notice', true);notice.style.display = 'none'">x</span></div>
</div>
</div>
<script>
var notice = document.getElementById("translation-notice")
if (localStorage.getItem("translation-notice") === null && notice !== null){
        notice.style.display = "block"
}
</script>
<nav class="navbar is-dark">
<div class="navbar-brand"><a class="navbar-item" href=
"/en/docs"><img style="max-height: 20px" src=
"/doku/static/images/logos/logo.png"></a> <span class=
"navbar-burger burger" data-target="side-menu" data-toggle=
"collapse"><span>&nbsp;</span> <span>&nbsp;</span>
<span>&nbsp;</span></span></div>
</nav>
<div class="main">
<div class="side-menu" id="side-menu" data-toggle-class=
"is-active">
<aside class="menu">
<p class="menu-label" style="text-align:center"><a href=
"/en/docs"><img style="max-height: 120px" src=
"/doku/static/images/logos/logo.png"> Lapwing!
Documentation</a></p>
<ul class="menu-list">
<li><a href="/en/docs">Start</a></li>
<li><a class="" href="#" data-toggle="collapse" data-target=
"page-system-nav">System</a>
<ul class="is-hidden" id="page-system-nav">
<li><a href="/en/docs/system/overview">Overview</a></li>
<li><a href="/en/docs/system/apis">APIs</a></li>
<li><a href="/en/docs/system/apps">Apps</a></li>
</ul>
</li>
<li><a href="/en/docs/protocol">Protocol</a></li>
<li><a href="/en/docs/contact">Contact</a></li>
<li><a href="#" data-toggle="collapse" data-target=
"menu-language-dropdown">Languages</a>
<ul id="menu-language-dropdown" class="is-hidden">
<li><a class="is-open is-active" href=
"/en/docs/protocol">English</a></li>
<li><a class="" href="/doku/protokoll">Deutsch</a></li>
</ul>
</li>
</ul>
</aside>
</div>
<div class="with-comments">
<div class="comments"></div>
<section class="section first">
<div class="content">
<div class="content markdown">
<h1>Protocol & System Design</h1>
<p>This document describes a decentralized, privacy-friendly
protocol & system for mediating appointments between two parties.
It is intended to be used, among other things, for privacy-friendly
mediation of vaccination appointments in the context of the
Covid-19 pandemic.</p>
<h2>Stakeholders</h2>
<p>There are the following players in the system:</p>
<ul>
<li><strong>Users</strong> book appointments with
<strong>providers</strong> (e.g. doctors).</li>
<li><strong>Providers</strong> make appointments available to
<strong>users</strong>.</li>
<li><strong>Mediators</strong> create trust between the actors in
the system.</li>
<li><strong>Backend operators</strong> run the IT infrastructure
needed for communication between the players.</li>
</ul>
<h2>Requirements</h2>
<p>The privacy and security of users and providers should be
protected as much as possible. Intermediaries and backend operators
should not be able to obtain information about users or providers.
They should also not be able to track whether appointments have
been made between specific providers and users, or reveal details
of these appointments. Intermediaries and backend operators should
nevertheless be able to detect and prevent misuse of the system (if
necessary with the support of users and providers).</p>
<p>The system should also be as robust as possible against abuse by
users and providers. It should be prevented that rogue providers
can contact users via the system or view data from them, that users
can resell appointments obtained via the system
(arbitrage/scalping), or that actors can impair the functionality
of the system for legitimate users or providers through spamming or
other techniques. Compromise of individual system components or
actors should have minimal impact on the privacy or security
guarantees of the system.</p>
<h2>System components</h2>
<p>The system consists of the following components:</p>
<ul>
<li><strong>User Frontend</strong> : A web/desktop/mobile
application used by users to register and book appointments.</li>
<li><strong>Provider Front End</strong> : A web/desktop/mobile
application used by providers to register and schedule
appointments.</li>
<li><strong>Intermediary Front End</strong> : A web/desktop/mobile
application used by intermediaries to verify providers, monitor the
system, and curb abuse.</li>
<li><strong>Data & authentication backends</strong> : An API-based
backend system that stores encrypted data of the above actors,
authenticates providers and cryptographically signs specific data
of users or providers. If necessary, backend services are split
into several services/APIs for this purpose.</li>
</ul>
<p>In the following, the term "app" is used to refer to the
applications of individual players; this does not necessarily mean
a mobile app.</p>
<h2>Protocol <code>v0.1</code></h2>
<p>The following sections describe the protocol for appointment
switching and the system components used for this purpose
(cryptographic operations and data flows are not described in full
detail).</p>
<h3>Notes</h3>
<p>For simplicity, the document refers to encryption using
asymmetric (ECDH) key pairs. This refers in each case to a key
derivation based on a (temporary or permanent) ECDH key pair in
combination with a symmetric encryption method (e.g. AES-GCM). When
talking about public or private keys for the encryption of data in
the context of bidirectional communication (e.g. between providers
and users), it is further implied that these keys are modified via
a suitable key derivation procedure (e.g. a Diffie-Hellman ratchet)
for each exchanged message.</p>
<h3>Abstract</h3>
<p>Appointments are arranged in several predominantly automated and
asynchronous steps:</p>
<ul>
<li>Intermediaries are registered by the backend operator.</li>
<li>Providers register and request verification through
intermediaries.</li>
<li>Intermediaries verify providers and grant them access to the
system.</li>
<li>Users register and submit (anonymous) appointment requests for
a given catchment area.</li>
<li>Providers retrieve appointment requests and create appointment
offers for specific users.</li>
<li>Users select dates from the offers and book them.</li>
<li>Providers verify user data and confirm booked
appointments.</li>
<li>Users and providers may change or cancel booked
appointments.</li>
</ul>
<p>All communication between providers and users is encrypted
end-to-end, the backend system stores the encrypted data without
assignment to specific providers or users and can therefore hardly
derive metadata about them. If external systems (e-mail, SMS) are
used for communication or verification, this is only done on an ad
hoc basis with the cooperation of providers; the corresponding
contact data (e-mail addresses, telephone numbers) are only
accessible to users themselves and to the operators of external
systems for specific purposes and on an ad hoc basis.</p>
<h3>1. mediator initialization</h3>
<p>Intermediaries act as a certificate authority (CA) in the system
and create an ECDSA signature key pair and an associated
certificate $C<em>\mathrm{auth}$, which is stored as a trust anchor
(root certificate) in the backend. Furthermore, they create ECDH &
ECDSA key pairs $(K</em>\mathrm{auth}^\mathrm{enc,priv},
K<em>\mathrm{auth}^\mathrm{enc,pub}),
(K</em>\mathrm{auth}^\mathrm{sign,priv},
K_\mathrm{auth}^\mathrm{sign,pub})$, whose signed public keys are
stored in the backend.</p>
<p>The agent app creates a random Salt value (32 bytes of random
data) for each of the relevant catchment areas (e.g. based on
postcodes) and saves the list of catchment areas with relevant data
and the associated Salt values in the backend. This can be called
up publicly from there. For each catchment area, the mediator app
also creates an ECDH key pair
$(K<em>\mathrm{r</em>i}^\mathrm{enc,priv},
K<em>\mathrm{r</em>i}^\mathrm{enc,pub})$. The private key
$K<em>\mathrm{r</em>i}^\mathrm{enc,priv}$ is encrypted by the
backend with the public key of relevant providers (see below)
during provider initialization and stored for them in the backend.
The public key is published together with the catchment area
data.</p>
<h3>2. backend initialization</h3>
<p>Backends have a randomly generated key (32 bytes of random data)
with the aid of which priority tokens are derived using a suitable
key derivation procedure (e.g. HKDF), which are used in the further
process for priority determination. This key must be kept secret in
order to ensure the fairness of the scheduling process. Backends
also have signature key pairs
$(K<em>\mathrm{be}^\mathrm{sign,priv},
K</em>\mathrm{be}^\mathrm{sign,pub})$, which are used to sign
priority tokens.</p>
<h3>3. provider initialization</h3>
<p>Providers first authenticate themselves to the backend and
thereby gain access to the provider app. There, they enter relevant
data about their practice as well as information they would like to
display to users when scheduling appointments. The provider app
generates an ECDH key pair
$(K<em>\mathrm{op</em>i}^\mathrm{enc,priv},K<em>\mathrm{op</em>i}^\mathrm{enc,pub})$,
encrypts the entered data with the public provider key and uploads
it to the backend for verification, linked to a random ID (32 bytes
of random data). Intermediaries retrieve the data from there,
decrypt and verify it, and sign successfully verified data with
their private signing key $K<em>\mathrm{auth}^\mathrm{sign,priv}$.
Additionally, they sign the public key
$K</em>\mathrm{op_i}^\mathrm{enc,pub}$ of the provider. The
mediator app again encrypts this data with the provider key and
stores it under the given ID in the backend. The signed provider
public key is additionally published via the backend, and the
associated provider data is encrypted with a randomly generated
symmetric key from the provider app and also stored there (this
allows intermediaries to control providers later). The provider app
downloads the signed data from the backend and decrypts it.</p>
<p>Providers now create appointments in their app, which are saved
locally in the app. This completes the initialization on the
provider side. Ideally, the app must be opened continuously, or at
least regularly, for appointment scheduling.</p>
<h3>4. user initialization</h3>
<p>Users open the user app, which can be used without
authentication. They enter relevant personal data (name, address,
e-mail and telephone number, if applicable). The user app generates
an ECDH key pair
$(K<em>\mathrm{u</em>i}^\mathrm{enc,priv},K<em>\mathrm{u</em>i}^\mathrm{enc,pub})$
as well as a nonce value (32 bytes of random data), links this with
the specified data and creates a hash value $H<em>i$ from it. This
value is sent to the authentication backend, which generates a
priority token $P</em>i$ (32-byte random data) and signs it
together with the hash value $H<em>i$ from the backend:
$S</em>i^{PH} = \mathrm{sign}((H<em>i,
P</em>i),K_\mathrm{be}^\mathrm{sign,priv})$. The signature links
the priority token with the data provided by users (without knowing
it) and thus prevents users from reselling the token.</p>
<p>Users now select a catchment area and create an anonymous
appointment request for it. If necessary, this is provided with
additional information (e.g. desired vaccine). The data of the
appointment request is encrypted by the user app together with a
randomly generated ID (32-byte random data) with the public key of
the catchment area and uploaded to the backend together with the
priority token. Here, the backend ensures that priority tokens
cannot be uploaded multiple times. This completes the user
initialization.</p>
<h3>5. create a time slot offer</h3>
<p>The appointment requests uploaded by users in catchment areas
can be sorted by the backend according to the priority tokens
specified. This creates a dynamic, prioritized list of users for a
given catchment area. Provider apps request a small number of user
requests from each of these lists. They can decrypt these using the
private key of the catchment area (which is provided to them in
encrypted form via the backend). They check the appointment request
against available capacity, create appointment offers, encrypt them
along with the signed practice data using the user's public key,
and store the data in the backend under the ID provided by the user
app. The data is additionally signed with the private signature
key. Each time slot is assigned a random ID.</p>
<p>The provider app signals the specific intent to the backend
before creating an appointment offer. The backend associates the
requests with a priority token and removes this token from the
priority list after a given number of received offers (temporarily
at first). This prevents users who are not responsive from
receiving a very large number of appointment offers, while users
with lower priority tokens do not receive any offers.</p>
<p>Optionally, the app generates a notification for the user using
an external service (e.g. in the form of an email notification).
This requires the user to provide such contact details in encrypted
form in the appointment request (see below).</p>
<p>The provider app can assign appointments multiple times in order
to achieve a sufficient occupancy of appointments. User apps can
dynamically detect appointments that have already been allocated
and, if necessary, request a new appointment allocation if all
offers have already been allocated. The optimal overbooking rate
depends on various factors and must be dynamically optimized in the
system.</p>
<h3>6. accept appointment offer (user)</h3>
<p>The user app regularly checks whether data is available in the
backend under the ID created in step 4 (the user may also receive a
notification about this via an external service). If so, the app
retrieves this data and decrypts it with the private user key. The
user app then checks the signatures (provider & agent signature) of
all offers and removes invalid offers. The valid dates are
displayed to users for selection. They select a suitable one from
the dates. The user app now encrypts the user data specified during
initialization and the signed priority token with the public key of
the provider and uploads the encrypted data with the ID specified
in the offer to the backend. A check of the IDs still available can
be carried out in advance in the backend (since time slots can be
sent to several users in parallel).</p>
<h3>7. confirm time slot offer (supplier)</h3>
<p>The provider app regularly checks whether data is available in
the backend under the IDs created in step 5. If so, the app
retrieves this data and decrypts it with the private key generated
in step 5. Then, the app checks whether the specified priority
token matches the originally specified token. Additionally, it
checks whether the signed hash value matches the hash value of the
user data calculated by the app. If necessary, providers can still
manually check the specified user data or automatically request
verification via an external service (see below). The app then
creates an appointment confirmation, encrypts it with the user's
public key, and stores it in the backend under the previous ID.
Optionally, the app generates a notification for the user using an
external service (e.g. in the form of an email notification).</p>
<p>This concludes the appointment process.</p>
<h3>8. cancel or change appointments</h3>
<p>Users can cancel appointments via the app by sending an
encrypted request to the provider under the known ID. The provider
app can then generate a new appointment offer. In principle, other
communication options are also conceivable via this encrypted
channel; the functionality can be easily adapted to the use case
for this purpose.</p>
<h3>Extensions</h3>
<p>The following extensions to the protocol are conceivable and can
increase usability and security.</p>
<h4>Storing key material</h4>
<p>Since users, providers and intermediaries each require key
material in order to use the system, it is important to store this
material in a fail-safe manner. This can be done, for example, by
storing it as a file or via encrypted storage in a backend. In the
latter case, a randomly generated token or user-selected password
can be used to encrypt the data locally before uploading. The
password/token can be written down by users or stored in the form
of a bookmark. If a user-selected password is used, a randomly
generated ID should also be chosen to uniquely identify the data.
In the case of a random token, a password as well as an ID can be
generated from it using a key derivation.</p>
<h4>Use of external services for verification & notification of
users</h4>
<p>The verification of data (e.g. e-mail addresses or telephone
numbers) can be an effective instrument to combat misuse. However,
such verification is not privacy-friendly and is often
time-consuming and costly. It should therefore only be done on an
ad hoc basis and as late in the process as possible. Notification
of users via external services (e.g. via e-mail) is also often
useful, but for the same reasons should also only be carried out on
an ad hoc basis.</p>
<p>To enable such services, system components can be created which,
for example, implement e-mail or SMS transmission or reception.
These should only be able to be used on an occasion-related and
authenticated basis. For this purpose, the services can each
receive their own ECDH key pairs whose public keys are made known
to the user app. User data such as e-mail addresses or telephone
numbers can then be encrypted in the user app with the public key
of the respective service and added to an appointment request.
Providers can then use the encrypted data and an additional
authentication token to request verification or notification via
the corresponding external service. This service can decrypt the
user data with the private key and generate a corresponding e-mail
or SMS, for example. This ensures that providers do not have access
to the decrypted data at any time and that this data can only be
made available to external services on an ad hoc basis and with the
cooperation of users. These services can be operated independently
of the rest of the system. Since verification only takes place on
an ad hoc basis and, if necessary, after an initial check of the
data by providers, the volume of external services used can be
greatly reduced, which in turn reduces costs and effort
accordingly. The potential for misuse is also significantly reduced
by the purely authenticated usability of the services.</p>
<p>Contact data for use in external services can also be encrypted
multiple times to increase the purpose limitation. For example,
e-mail addresses or telephone numbers can be additionally encrypted
with the public key of the catchment area in order to be
decryptable only for providers from this area.</p>
<h4>Design of catchment areas</h4>
<p>Catchment areas can be structured not only geographically but
also according to other criteria. For example, it is conceivable to
define separate catchment areas for individual vaccines or age
groups. This can improve appointment finding and reduce the number
of data records that have to be viewed by providers. Providers can
then also be assigned to several catchment areas if necessary (e.g.
if they offer vaccinations with several vaccines).</p>
<h4>Recording and combating abuse</h4>
<p>From both the user and the provider side, there are several ways
to abuse the system:</p>
<ul>
<li>Actors may be able to register as providers in the system and
send appointment offers to users. If users accept these offers and
make their data available to the actors, they may be misused.</li>
<li>Actors can generate a large number of priority tokens and use
them to compromise the functionality of the system. They can also
try to resell priority tokens.</li>
<li>Actors may try to overwhelm the backend system by issuing a
large number of queries.</li>
</ul>
<p>To prevent these abuse scenarios, the system should provide
countermeasures. For example, users should be able to report
providers registered in the system that they do not consider
reputable. Intermediaries can then remove such providers from the
system by depublishing their public signature key, user apps will
then automatically remove all appointment offers of these providers
when loading the offers. However, such a "reporting" function can
also be misused, so it should also be subject to restrictions and
implement appropriate security measures.</p>
<p>Several countermeasures are conceivable to prevent the system
from being overwhelmed by a high number of abusively created
priority tokens. On the one hand, the overbooking rate of
appointments can be adjusted to the number of abusively created
tokens. In addition, individual user data can be verified. For this
purpose, data such as an e-mail address or a telephone number are
verified with the help of an external service (see above). This
service then generates a signature for the specified data, which
can additionally be linked to context information such as a
priority token. Providers can thus sort out user requests that do
not have verified contact data or require the user to verify the
data again. Again, external systems can be used for this purpose.
This can increase the hurdle for manipulation of the system by
malicious users.</p>
<p>To avoid overwhelming the system with a high number of backend
requests, the backend must be designed to withstand high request
volumes. Since authentication of users is generally not desirable
(since this results in a large number of possibilities for metadata
analysis), it must be ensured that users can only make requests
with context information if possible. This is possible in the given
system because providers can be authenticated more easily and they
create ID values on their own initiative, which users can then use
to send data to the backend. Users can thus only store data in the
backend knowing these values, and the storage of data under these
IDs can be limited via simple mechanisms. Only for the storage of
encrypted settings/user data this is not possible, but this backend
system can be operated separately from the rest of the system and
can easily be designed for large data volumes due to the simple
nature of storage.</p>
<h4>Decentralized & federated operation</h4>
<p>In principle, all components of the system can be operated
redundantly and federated. Apps can communicate with multiple
backends and retrieve data from them or send data to them.
Likewise, several intermediaries can use one backend to register
providers and catchment areas. Thus, it is conceivable to assign
the registration and monitoring of providers to regionally specific
actors. Similarly, separate backends can be operated for different
regions, or multiple backends can be redundantly combined into a
more fail-safe system. Apps can also be distributed decentrally and
independently of the backend, so that they can also be adapted to
regional conditions, for example.</p>
</div>
</div>
</section>
</div>
</div>
<script defer type="text/javascript" src=
"/doku/static/js/bulma.js"></script>
</body>
</html>
